 Conditionals and Control Flow CSE 220: Systems Programming
Ethan Blanton & Carl Alphonce
Department of Computer Science and Engineering University at Buffalo

Advice: Time Management
The Carnegie Rule: 2-3 hours of work outside class per credit
That’s why 12 credits is full time!
Plan accordingly:
Schedule ~1.5 hours per lecture in a block
Too long: hard to focus
Too short: lost time to overhead
Work every day, not all at once
Schedule the other 0.5–1.5 hours as needed


Advice: Time Management
Keep a TODO!
Don’t lose time to “what do I do next?” Don’t miss deadlines
For every course:
10-15 minutes every week for TODO management Make a list of 5-7 items you can just do
If the list gets short, curate it!
Example items:
Good: Read Chapter 5 through 5.4
Good: PA1: Check command line arguments for validity Bad: PA1


Administrivia 1
Deadlines for the following items have already passed:
Lab 01
AI Quiz
PA0 Handout Quiz
If you haven’t completed the following, you are behind:
K&R up to and including 2.4 Finishing PA0


Administrivia 2
Deadlines for these items are coming up very soon: Lab 02
PA0
If you are struggling with deadlines, or are shy to ask for help, don’t be. Our job is to help you learn.
Impostor Syndrome is real!
If you already knew all of this, we wouldn’t make you take it.


Don’t abuse!
Our shared compute server emon.cse.buffalo.edu There are 425 of you, all using the same computer!
Don’t run VS Code on emon, or use VS Code remote access Do terminate programs and log off when leaving lab
Autolab
5 submissions is 5, 10 is questionable, 20 is too many
Office hours


Conditionals in C
Truth in C is simple but possibly non-intuitive: Bit-wise 0 is false
anything else is true
However, boolean expressions and true and false are less
unpredictable:
true and true results are exactly 1 false and false results are exactly 0


Control Flow
We have discussed only the for loop in C.
Required readings in K&R have covered other control flow. We will look at if and its implementation.
There are other control flow statements (discussed in K&R), but they behave similarly.


Boolean Operators
C uses the following Boolean operators:
!: Logical not; inverts the following expression
&&: Logical and; true iff the LHS and RHS are both true ||: Logical or; true if either the RHS or LHS is true
Do not confuse these with the similarly-named bitwise operators! (We will discuss those later.)


Boolean Logic in C
C uses short circuit evaluation for Boolean logic.
This means that evaluation of a Boolean sentence stops
as soon as its final truth value is known. For example:
x && y
If x is false, then this sentence is false. In that case, y will never be evaluated.



Short Circuit Consequences
The consequences of short-circuit evaluation can be surprising. If terms in the sentence have side effects, those side effects
may not run.
This can be very useful, but also surprising!
if (i < len && array[i] == SOMEVAL) {
/* Useful! If array[i] is past the end of the
}
array, the illegal access never happens. */



Equality Operators
There are two equality operators:
==: Compares value equality, returns true if equal !=: Compares value equality, returns false if equal
Note that these operators compare values, not logical truth!
In particular, note that many values are “true”, but true is 1! This means that two logically true values may compare unequal.



Truthiness
bool x = true; int y = 2;
if (x)
printf("x is true\n");
if (y)
printf("y is true\n");
if (x == y)
printf("x and y are equal\n");



Truthiness
bool x = true; int y = 2;
if (x)
printf("x is true\n");
if (y)
printf("y is true\n");
if (x == y)
printf("x and y are equal\n");
Output:
x is true y is true



stdbool
The header #include <stdbool.h> defines some useful things. The type bool, which holds only 0 or 1
The values true and false
Before C99, these things didn’t exist in the standard, but were widely defined in programs.
Therefore they were standardized to require a header. bool b = 2;
printf("%d\n", b);
Output:
1



Control Flow
Control flow is the path that execution takes through a program. The C model is linear flow by default.
Control flow statements can change the order of execution. This is how our programs make decisions.
We will examine how this flow is achieved.



The if Statement
The simplest control statement in C is if.
Its syntax is:
if (condition) { body;
}
If the expression condition evaluates to any true value, body
runs.
Otherwise, body is skipped.



Implementing if
The if statement must be compiled to machine instructions.
Those machine instructions must encode the condition check and jump.
This is normally implemented as a conditional branch instruction.
You don’t have to learn assembly for this course, but we will look at some machine instruction concepts.



A Simple Condition — C
int main(int argc, char *argv[]) {
if (argc == 2 && argv[1][0] == '-') { puts("negative");
}
return 0; }



A Simple Condition — Assembly
.L4:
.L8:
cmpl $2, %edi je .L8
xorl %eax, %eax ret
; compare argc to 2 ; jump to .L8 if ==
; set up return value ; return 0
; load argv[1][0] to %rax ; compare %rax to 45 ('-') ; jump to .L4 if !=
movq 8(%rsi), %rax
cmpb $45, (%rax)
jne .L4
leaq .LC0(%rip), %rdi; load "negative" to %rdi subq $8, %rsp ; make room on stack
call puts@PLT ; call puts("negative") ; another return 0 goes
here



Conditional Instruction Flow
Note that the structure of the program was lost.
One of the advantages of high-level languages is structure.
The computer can generally only:¶
Make simple comparisons (sometimes only to zero!) Jump to a program location
Anything more complicated is a software construction.



The else Clause
The else clause is simply either:
The next instruction after a jump
The jump destination (with the if body being the next
instruction)
Which layout the compiler uses depends on the code and architecture.



else Gotchas
I strongly advocate always using blocks.
Here is a place where it really matters:
if (modify_x) if (negate)
x = x * -1; y = -x;
else



else Gotchas
I strongly advocate always using blocks.
What this actually means is:
if (modify_x) if (negate)
x = x * -1;
else
y = -x;



else Gotchas
I strongly advocate always using blocks.
What you should use is:
if (modify_x) { if (negate) {
x = x * -1; }
} else {
y = -x;
}



Summary
All nonzero values are true conditions in C.
All Boolean expressions use 1 for true.
The bool keyword holds only 0 or 1.
C uses short-circuit evaluation of Boolean logic.
Control flow is implemented with comparisons and jumps. Use blocks for if and else!



Next Time ...
POSIX memory model Pointer types
Process layout



References I
Required Readings
[1] Brian W. Kernighan and Dennis M. Ritchie. The C Programming Language. Second Edition. Chapter 2: 2.6; Chapter 3: Intro, 3.1–3.7. Prentice Hall, 1988.



License
Copyright 2020, 2021, 2023 Ethan Blanton, All Rights Reserved. Copyright 2022, 2023 Carl Alphonce, All Rights Reserved. Copyright 2019 Karthik Dantu, All Rights Reserved.
Reproduction of this material without written consent of the author is prohibited.
To retrieve a copy of this material, or related materials, see https://www.cse.buffalo.edu/~eblanton/.

 